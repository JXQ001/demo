redis
1.内存淘汰机制
    ①从已设置过期时间的数据集中淘汰(server.db[i].expires)
        随机过期数据(volatile-random)
        最少使用的数据(volatile-ttl)
        将要过期的数据(volatile-lru)
    ②当内存不足以容纳写入数据时，在键空间中，移出最近最少使用的key(allkeys-lru),常用
    ③从数据集(server.db[i].dict)中随机任意选择数据淘汰（allkeys-random）
    ④禁止驱逐数据（no-eviction），内存不足写入报错，不使用
2.持久化
    ①快照（RDB）,默认的持久化方式，save 900 1 900秒后1个key变化会触发
    ②追加（AOF），默认不开启，通过appendonly yes 开启，
    ③redis4.0之后支持RDB和AOF混合持久化，默认关闭，通过aof-use-rdb-preamble开启
3.缓存雪崩和缓存穿透问题
    ①缓存雪崩，缓存同一时间失效，请求落到数据库，导致数据库短时间承受大量请求崩掉。
        解决：
            1.事前，保证redis集群的高可用，选择合适的内存淘汰策略
            2.事中，本职ehcache+限流组件缓存
            3.事后，利用持久化机制保存的数据恢复缓存
    ②缓存穿透，用户请求缓存中不存在的数据，导致请求落在数据库上，造成数据库短时间承受大量数据崩掉。
            解决：
            1.使用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被拦截
            2.粗暴的方法，将查询为空（不管数据不存在，系统故障）的数据也进行缓存，设置较短的过期时间
